\section{Introduction}

The deployment of Cloud-Native applications (CNA), relies on placing a collection of small, independent, loosely
coupled and, ideally, self-managed services into a cluster. This architectural style brings some advantages to the
applications. Due to the high decoupling of application's components, it is possible to isolate failures to avoid the
crash of the whole application. Moreover, this architectural style allows a decoupled evolution of the application by
updating their components individually. However, the high decoupling in this architectural style makes difficult the
application management, since there are a large number of distributed pieces of software that the engineers should
handle during the application execution.

To mitigate some of challenges on the management of CNA, their services are mostly bundled up with several runtime
abstraction layers to facilitate the their execution or runtime management. Some examples of these layers are
application servers (e.g., OpenLiberty), runtime environment (e.g., Java Virtual Machine), hardware isolation (e.g.,
containers and virtual machines), and cluster orchestrator (e.g., Kubernetes).

Runtime abstractions layers are general purpose with many parameters (knobs), that the application engineer adjusts to
better satisfy the use cases of the application. Many of these knobs are related to data structures or infrastructure
mechanisms, so their adjustment affects the application performance. An important issue regarding these knobs is the
colossal number of possibilities that an engineer has to consider to improve the application execution.

Every layer added to an application increases exponentially the number of possible configurations that the engineer has
available to experiment. Making matters worse, an optimal configuration for an application is mutable, it should
changes according to the environment, such as fluctuations of number of users requests, saturation of the cluster,
version of libraries being used, and so on. For tuning an application the engineer has to evaluate many different
configurations to find one that extracts the most of the application performance for a given situation.

To tackle this challenge, we are proposing \name, a mechanism to automatically identify and apply optimal
configurations onto CNA regarding the environment where the application is deployed. The rational of this mechanism is,
based on changes of the application workloads along the time (incoming requests, resources consumption and application
performance), find out and continually updates, an optimal configuration which extracts the maximum performance of the
application and for some scenarios it also might reduce the application resource consumption.

\arsj{think about small example at end of section 1 that has example complex enough to show value of prediction and
tuning: load balancer and database}
