\section{\name challenges}

In this section we exemplify the use of \name with a real application and
discuss the main challenges on applying its approach in real world.
AcmeAir\urlfoot{https://github.com/blueperf/acmeair-monolithic-java} is an
implementation of a fictitious airline developed in Java. The application was
built with the ability to scale to billions of web API calls per day. AcmeAir is
bundled up with several runtime layers each one dealing with a specific aspect
of application execution, \fig{fig:acmeair-bundle}. The inner most layer is the
application server OpenLiberty which transparently handle connections to
database, components integration, and monitoring of the application. Next, as a
Java application, both AcmeAir and OpenLiberty runs on the JVM, which abstracts
the execution of code, and the management of memory and threads. All these
components are encapsulated into a Docker Container, which abstracts the file
system layer and several libraries of the OS. Finally, the container is
encapsulated into a Kubernetes Pod, which abstracts aspects regarding the
cluster management such as scaling out and roll out new version.

\begin{figure*}[htp]
    \centering
    \def\svgwidth{\textwidth}
    \scalebox{1.0}{\input{figs/acmeair-bundle.pdf_tex}}
    \caption{AcmeAir bundle.}
    \label{fig:acmeair-bundle}
\end{figure*}

Each of these layers exposes its own configuration interface with many options
that engineers uses to set up the execution of the application. The combination
of configurations among interfaces affects the behavior of the application. For
example, the number of threads set in the OpenLiberty's thread pool is directly
affected with the max heap size set in JVM, the number of cores and memory
available set in containers, and the affinity set in a pod, so that Kubernetes
deploys the application into nodes with more or less co-located pods. Therefore,
a misconfiguration in one of these layers can potentially drops the performance
of the application. We can notice that for the simple aspect of thread pool
size, the number of possibilities may easily explode to hundreds of valid
configurations, making unfeasible for engineers try all, while looking for one
that maximizes the applications performance.

An application like AcmeAir has several aspects which engineers want to tune.
Moreover, some of these configurations have interdependences in a same level,
for example, the number of max connections which should remain opened in
OpenLiberty depends on the size of its thread pool. Or, the garbage collection
policy set depends on the heap size available in the JVM, and so on. It
increases even more the complexity to find out and try all valid configurations
of an application.

Another consideration when configuring application is the impact of the
environment on itself. An application running with a same configuration and a
same rate of incoming requests may have different performance along the time,
thanks to fluctuations of other applications in the cluster. For instance, in a
given time AcmeAir is deployed with very few other co-located applications.
However, in another time AcmeAir remains with the same incoming rate and number
of replicas, but the number of replicas of other applications drastically
increase. Consequently, AcmeAir starts to suffer CPU contention by other
replicas co-located in the cluster node dropping its performance.

Finally, modern CNA like AcmeAir are frequently evolving, and every next
evolution may require a different configuration, which adds a new level of
complexity to find optimal configurations to the application. At the end of the
day, it becomes impossible for application's engineers try all possible
configurations for each new scenario manually. To handle it, the engineers
attempts a same configuration which suits the application in all possible
scenarios.  However, they have no guarantee if this configuration will be good
enough for the whole application lifetime, and a careless set up eventually
leads the application to a bad performance.

We propose \name to automatically support the search of good configurations for
applications. \name identifies configurations based on analysis of the
environment around the application and the application itself, tuning the
application to reach the best performance possible. The concept of automatically
tuning application's configuration is well known and successfully applied in
context of machine learning~\cite{}, in this domain named \emph{hyper parameters
optimization}. However, apply the same strategies of machine learning in the
context of CNA might be a naive solution.

As we mentioned, CNA are dynamic and sensible applications which suffer with
changes on itself (architecture or configuration) and on the environment where
it is deployed, so that its behavior changes many times along its lifespan.
Moreover, a CNA must satisfy many functional and non-functional requirements,
which makes itself a ``multi-purpose'' application, with due proportions.
Lastly, the lifespan of a CNA is nondeterministic, it runs in definitely since
in most of cases it is providing a service for people or other applications.

On the other hand, machine learning applications are mostly defined to satisfy a
single functional requirement -- training a model to do specific task -- with
very few non-functional requirements -- it should be fast and their outcome must
have the minimum error.  Besides, machine learning applications does not evolve
frequency like CNAs, neither suffer so much impacts from the environment, since
these application are used to run in dedicated hardware.  Therefore, once it is
figured out an optimal configuration for a machine learning application, it
remains the same during its whole lifespan, which differently of CNA it is
deterministic.

Therefore, in order to make possible apply the idea of automatically find out
configurations to application (or auto-tuning), we are assuming that changes on
the environment and on the application are periodical, so that \name can
identify patterns and associate them to configurations. Every new pattern that
\name observes from application or environment, which drops the application
performance, trigger \name to figure out a best new configuration for this
pattern. Hence, \name can handle this pattern properly in the next time it comes
up.

Although the benefits brought by using \name, it is no free lunch. Even \name
doing the hard work searching for an optimal configuration automatically, it may
be unfeasible to get an optimal configuration in a reasonable short time.  \name
should be used in collaboration with the application engineers, so that they
delimit the search space boundaries for \name looking for optimal configurations
in a limited scope. Furthermore, we list in \crossref{sec:design.choices} other
choices we made to make possible apply auto-tuning in CNAs.
